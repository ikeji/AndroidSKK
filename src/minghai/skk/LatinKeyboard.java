/*
 * Copyright (C) 2008-2009 Google Inc.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package minghai.skk;

import android.content.Context;
import android.content.res.Resources;
import android.content.res.XmlResourceParser;
import android.graphics.drawable.Drawable;
import android.inputmethodservice.Keyboard;
import android.inputmethodservice.Keyboard.Key;
import android.inputmethodservice.Keyboard.Row;
import android.view.inputmethod.EditorInfo;

public class LatinKeyboard extends Keyboard {
  private Drawable mShiftLockIcon;
  private Drawable mShiftLockPreviewIcon;
  private Drawable mOldShiftIcon;
  private Drawable mOldShiftPreviewIcon;
  private Key mShiftKey;
  private Key mEnterKey;
  
  private static final int SHIFT_OFF = 0;
  private static final int SHIFT_ON = 1;
  private static final int SHIFT_LOCKED = 2;
  
  private int mShiftState = SHIFT_OFF;
  
  public LatinKeyboard(Context context, int xmlLayoutResId) {
      this(context, xmlLayoutResId, 0);
  }

  public LatinKeyboard(Context context, int xmlLayoutResId, int mode) {
      super(context, xmlLayoutResId, mode);
      mShiftLockIcon = context.getResources()
              .getDrawable(R.drawable.sym_keyboard_shift_locked);
      mShiftLockPreviewIcon = context.getResources()
              .getDrawable(R.drawable.sym_keyboard_feedback_shift_locked);
      mShiftLockPreviewIcon.setBounds(0, 0, 
              mShiftLockPreviewIcon.getIntrinsicWidth(),
              mShiftLockPreviewIcon.getIntrinsicHeight());
  }

  public LatinKeyboard(Context context, int layoutTemplateResId, 
          CharSequence characters, int columns, int horizontalPadding) {
      super(context, layoutTemplateResId, characters, columns, horizontalPadding);
  }

  @Override
  protected Key createKeyFromXml(Resources res, Row parent, int x, int y, 
          XmlResourceParser parser) {
      Key key = new LatinKey(res, parent, x, y, parser);
      if (key.codes[0] == 10) {
          mEnterKey = key;
      }
      return key;
  }
  
  void setImeOptions(Resources res, int mode, int options) {
      if (mEnterKey != null) {
          // Reset some of the rarely used attributes.
          mEnterKey.popupCharacters = null;
          mEnterKey.popupResId = 0;
          mEnterKey.text = null;
          switch (options&(EditorInfo.IME_MASK_ACTION|EditorInfo.IME_FLAG_NO_ENTER_ACTION)) {
              case EditorInfo.IME_ACTION_GO:
                  mEnterKey.iconPreview = null;
                  mEnterKey.icon = null;
                  mEnterKey.label = res.getText(R.string.label_go_key);
                  break;
              case EditorInfo.IME_ACTION_NEXT:
                  mEnterKey.iconPreview = null;
                  mEnterKey.icon = null;
                  mEnterKey.label = res.getText(R.string.label_next_key);
                  break;
              case EditorInfo.IME_ACTION_DONE:
                  mEnterKey.iconPreview = null;
                  mEnterKey.icon = null;
                  mEnterKey.label = res.getText(R.string.label_done_key);
                  break;
              case EditorInfo.IME_ACTION_SEARCH:
                  mEnterKey.iconPreview = res.getDrawable(
                          R.drawable.sym_keyboard_feedback_search);
                  mEnterKey.icon = res.getDrawable(
                          R.drawable.sym_keyboard_search);
                  mEnterKey.label = null;
                  break;
              case EditorInfo.IME_ACTION_SEND:
                  mEnterKey.iconPreview = null;
                  mEnterKey.icon = null;
                  mEnterKey.label = res.getText(R.string.label_send_key);
                  break;
              default:
                  if (mode == KeyboardSwitcher.MODE_IM) {
                      mEnterKey.icon = null;
                      mEnterKey.iconPreview = null;
                      mEnterKey.label = ":-)";
                      mEnterKey.text = ":-) ";
                      mEnterKey.popupResId = R.xml.popup_smileys;
                  } else {
                      mEnterKey.iconPreview = res.getDrawable(
                              R.drawable.sym_keyboard_feedback_return);
                      mEnterKey.icon = res.getDrawable(
                              R.drawable.sym_keyboard_return);
                      mEnterKey.label = null;
                  }
                  break;
          }
          // Set the initial size of the preview icon
          if (mEnterKey.iconPreview != null) {
              mEnterKey.iconPreview.setBounds(0, 0, 
                      mEnterKey.iconPreview.getIntrinsicWidth(),
                      mEnterKey.iconPreview.getIntrinsicHeight());
          }
      }
  }
  
  void enableShiftLock() {
      int index = getShiftKeyIndex();
      if (index >= 0) {
          mShiftKey = getKeys().get(index);
          if (mShiftKey instanceof LatinKey) {
              ((LatinKey)mShiftKey).enableShiftLock();
          }
          mOldShiftIcon = mShiftKey.icon;
          mOldShiftPreviewIcon = mShiftKey.iconPreview;
      }
  }

  void setShiftLocked(boolean shiftLocked) {
      if (mShiftKey != null) {
          if (shiftLocked) {
              mShiftKey.on = true;
              mShiftKey.icon = mShiftLockIcon;
              mShiftState = SHIFT_LOCKED;
          } else {
              mShiftKey.on = false;
              mShiftKey.icon = mShiftLockIcon;
              mShiftState = SHIFT_ON;
          }
      }
  }

  boolean isShiftLocked() {
      return mShiftState == SHIFT_LOCKED;
  }
  
  @Override
  public boolean setShifted(boolean shiftState) {
      boolean shiftChanged = false;
      if (mShiftKey != null) {
          if (shiftState == false) {
              shiftChanged = mShiftState != SHIFT_OFF;
              mShiftState = SHIFT_OFF;
              mShiftKey.on = false;
              mShiftKey.icon = mOldShiftIcon;
          } else {
              if (mShiftState == SHIFT_OFF) {
                  shiftChanged = mShiftState == SHIFT_OFF;
                  mShiftState = SHIFT_ON;
                  mShiftKey.icon = mShiftLockIcon;
              }
          }
      } else {
          return super.setShifted(shiftState);
      }
      return shiftChanged;
  }
  
  @Override
  public boolean isShifted() {
      if (mShiftKey != null) {
          return mShiftState != SHIFT_OFF;
      } else {
          return super.isShifted();
      }
  }

  static class LatinKey extends Keyboard.Key {
      
      private boolean mShiftLockEnabled;
      
      public LatinKey(Resources res, Keyboard.Row parent, int x, int y, 
              XmlResourceParser parser) {
          super(res, parent, x, y, parser);
          if (popupCharacters != null && popupCharacters.length() == 0) {
              // If there is a keyboard with no keys specified in popupCharacters
              popupResId = 0;
          }
      }
      
      void enableShiftLock() {
          mShiftLockEnabled = true;
      }

      @Override
      public void onReleased(boolean inside) {
          if (!mShiftLockEnabled) {
              super.onReleased(inside);
          } else {
              pressed = !pressed;
          }
      }
      
      /**
       * Overriding this method so that we can reduce the target area for certain keys.
       */
      @Override
      public boolean isInside(int x, int y) {
          if ((edgeFlags & Keyboard.EDGE_BOTTOM) != 0 ||
                  codes[0] == KEYCODE_SHIFT ||
                  codes[0] == KEYCODE_DELETE) {
              y -= height / 10;
          }
          if (codes[0] == KEYCODE_SHIFT) x += width / 6;
          if (codes[0] == KEYCODE_DELETE) x -= width / 6;
          return super.isInside(x, y);
      }
  }
}
